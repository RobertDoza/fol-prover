%{

#include <iostream>
#include <memory>
#include "formula.hpp"
#include "quantifier.hpp"
#include "connective.hpp"
#include "atom.hpp"
#include "term.hpp"

extern int yylex();

void yyerror(const char* s);

std::shared_ptr<Formula> parsed_formula;

%}

%union {
	char *str;
	Term *term;
	std::vector<std::shared_ptr<Term>> *term_vec;
	AtomicFormula *atomic_formula;
	Formula *formula;
}

%token TRUE
%token FALSE
%token <str> SYMBOL
%token <str> VAR
%token NOT
%token AND
%token OR
%token IMPLIES
%token IFF
%token FORALL
%token EXISTS

%type <term> term
%type <term_vec> term_list
%type <atomic_formula> atomic_formula
%type <formula> formula
%type <formula> quantified_formula
%type <formula> connective
%type <formula> implication
%type <formula> disjunction
%type <formula> conjunction
%type <formula> equivalence
%type <formula> negation
%type <formula> subformula

%%

input:
	formula {
		std::shared_ptr<Formula> f($1);
		
		parsed_formula = f;
	}
	;

formula:
	quantified_formula {
		$$ = $1;
	}
	;

quantified_formula:
	FORALL VAR '.' quantified_formula {
		$$ = new ForAll( $2, std::shared_ptr<Formula>($4) );
	}
	| EXISTS VAR '.' quantified_formula {
		$$ = new Exists( $2, std::shared_ptr<Formula>($4) );
	}
	| connective {
		$$ = $1;
	}
	;

connective:
	implication {
		$$ = $1;
	}
	;

implication:
	disjunction IMPLIES implication {
		$$ = new Implication( std::shared_ptr<Formula>($1), std::shared_ptr<Formula>($3) );
	}
	| disjunction {
		$$ = $1;
	}
	;

disjunction:
	conjunction OR disjunction {
		$$ = new Disjunction( std::shared_ptr<Formula>($1), std::shared_ptr<Formula>($3) );
	}
	| conjunction {
		$$ = $1;
	}
	;

conjunction:
	equivalence AND conjunction {
		$$ = new Conjunction( std::shared_ptr<Formula>($1), std::shared_ptr<Formula>($3) );
	}
	| equivalence {
		$$ = $1;
	}
	;

equivalence:
	equivalence IFF negation {
		$$ = new Equivalence( std::shared_ptr<Formula>($1), std::shared_ptr<Formula>($3) );
	}
	| negation {
		$$ = $1;
	}
	;

negation:
	NOT negation {
		$$ = new Negation( std::shared_ptr<Formula>($2) );
	}
	| subformula {
		$$ = $1;
	}
	;

subformula:
	atomic_formula {
		$$ = $1;
	}
	| '(' formula ')' {
		$$ = $2;
	}
	;

atomic_formula:
	TRUE {
		$$ = new True();
	}
	| FALSE {
		$$ = new False();
	}
	| SYMBOL {
		$$ = new SimpleAtom($1);
	}
	| SYMBOL '(' term_list ')' {
		$$ = new ComplexAtom($1, *$3);
	}
	;

term:
	SYMBOL {
		$$ = new Constant($1);
	}
	| VAR {
		$$ = new Variable($1);
	}
	| SYMBOL '(' term_list ')' {
		$$ = new ComplexTerm($1, *$3);
	}
	;

term_list:
	term {
		$$ = new std::vector<std::shared_ptr<Term>>{ std::shared_ptr<Term>($1) };
	}
	| term ',' term_list {
		$3->insert($3->begin(), std::shared_ptr<Term>($1));
		$$ = $3;
	}
	;

%%

std::shared_ptr<Formula> parse_formula() {
	yyparse();
	
	if (!parsed_formula) {
		throw std::runtime_error("Formula not parsed correctly!");
	}
	
	return parsed_formula;
}

void yyerror(const char* s) {
    std::cerr << "Error: " << s << std::endl;
}

